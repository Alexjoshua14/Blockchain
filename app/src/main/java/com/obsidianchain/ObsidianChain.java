/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.obsidianchain;

import com.obsidianchain.components.*;
import com.obsidianchain.utilities.*;
import com.google.gson.GsonBuilder;
import java.util.ArrayList;
import java.security.Security;
import java.util.Base64;
import java.util.HashMap;

public class ObsidianChain {
    public final static int DIFFICULTY = 5;
    public final static float minimumTransaction = 0.1f;
    public static ArrayList<Block> blockchain = new ArrayList<Block>();
    public static Transaction gensisTransaction;

    //Keeps track of unspent coins
    public static HashMap<String, TransactionOutput> UTXOs = new HashMap<String, TransactionOutput>();

    private static Wallet walletA;
    private static Wallet walletB;

    public String getGreeting() {
        return "Hello World!";
    }

    public static void addBlock(Block block) {
        block.mine(DIFFICULTY);
        blockchain.add(block);
    }

    public static boolean isChainValid() {
        Block currBlock;
        Block prevBlock;
        String hashTarget = new String(new char[DIFFICULTY]).replace('\0', '0');

        for (int i = 1; i < blockchain.size(); i++) {
            prevBlock = blockchain.get(i-1);
            currBlock = blockchain.get(i);

            // Verify current hash
            if (!currBlock.hash.equals(currBlock.calculateHash())) {
                System.out.println("Current hash for block:" + i + " does not match what it should be.");
                return false;
            }

            // Verify previous hash
            if (!prevBlock.hash.equals(currBlock.previousHash)) {
                System.out.println("Current block's previousHash does not match previous block's hash");
                return false;
            }

            //Verify hash has been solved
            if (!currBlock.hash.substring(0, DIFFICULTY).equals(hashTarget)) {
                System.out.println("This block has yet to be mined");
                return false;
            }

        }

        return true;
    }

    public static void main(String[] args) {
        ObsidianChain oc = new ObsidianChain();

        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

        walletA = new Wallet();
        walletB = new Wallet();

        Wallet bifold = new Wallet();

        Transaction genesisTransaction = new Transaction(bifold.getPublicKey(), walletA.getPublicKey(), 100f, null);
        genesisTransaction.generateSignature(bifold.getPrivateKey());
        genesisTransaction.transactionId = "0";
        genesisTransaction.outputs.add(new TransactionOutput(
                                                genesisTransaction.recipient, 
                                                genesisTransaction.value, 
                                                genesisTransaction.transactionId));
        UTXOs.put(genesisTransaction.outputs.get(0).id, genesisTransaction.outputs.get(0));

        System.out.println("Creating and mining the genesis block..");

        Block genesis = new Block("0");
        genesis.addTransaction(genesisTransaction);
        addBlock(genesis);

        // Additional blocks for testing purposes
        Block block1 = new Block(genesis.hash);
        System.out.println("Wallet A's balance is: " + walletA.getBalance());
        System.out.println("Wallet B's balance is: " + walletB.getBalance());
        System.out.println("Wallet A is attempting to send funds (40) to Wallet B..");        
        block1.addTransaction(walletA.sendFunds(walletB.publicKey, 40f));
        addBlock(block1);
        System.out.println("Wallet A's balance is: " + walletA.getBalance());
        System.out.println("Wallet B's balance is:" + walletB.getBalance());

        Block block2 = new Block(block1.hash);
        System.out.println("Wallet A is attempting to send funds (1000) to Wallet B..");        
        block2.addTransaction(walletA.sendFunds(walletB.publicKey, 1000f));
        addBlock(block2);
        System.out.println("Wallet A's balance is: " + walletA.getBalance());
        System.out.println("Wallet B's balance is:" + walletB.getBalance());

        Block block3 = new Block(block2.hash);
        System.out.println("Wallet A is attempting to send funds (20) to Wallet B..");        
        block3.addTransaction(walletA.sendFunds(walletB.publicKey, 20));
        addBlock(block3);
        System.out.println("Wallet A's balance is: " + walletA.getBalance());
        System.out.println("Wallet B's balance is:" + walletB.getBalance());

        isChainValid();
    }
}
